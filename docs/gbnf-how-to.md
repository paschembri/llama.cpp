# How to Write Your Own GBNF Grammar

GBNF (GGML BNF) is a format for defining formal grammars to constrain the output of language models in `llama.cpp`. This guide will walk you through the syntax and concepts needed to create your own grammars. For a more general overview, you can also refer to the [GBNF Guide in the `grammars` directory](../grammars/README.md).

## Core Concepts

A GBNF grammar consists of a set of *production rules*. Each rule defines a *non-terminal* (a symbolic name for a pattern) and how it can be replaced by a sequence of *terminals* (actual characters) and/or other non-terminals.

The goal of a grammar is to define a language. Any sequence of characters that can be generated by starting with the `root` rule and following the production rules is considered part of the language defined by the grammar.

### 1. Rules (Non-Terminals)

Rules are the building blocks of your grammar. They represent different parts of the structure you want to generate.

*   **Naming:** Rule names (non-terminals) must be lowercase and can use dashes (e.g., `my-rule`, `list-item`, `json-object`).
*   **Definition:** A rule is defined using `::=`. The left side is the rule name, and the right side is its definition.
    ```gbnf
    root ::= "Hello, " name "!"
    name ::= "World" | "User" | "Jules"
    ```
    In this example, `root` and `name` are non-terminals.

### 2. Terminals (Characters)

Terminals are the actual characters or sequences of characters that will appear in the output.

*   **Literal Strings:** Enclose literal character sequences in double quotes.
    ```gbnf
    greeting ::= "Hello"
    ```
*   **Character Ranges:** Define a set of allowed characters using square brackets.
    ```gbnf
    digit ::= [0-9]  # Matches any digit from 0 to 9
    letter ::= [a-z] # Matches any lowercase letter from a to z
    hex-char ::= [0-9a-fA-F] # Matches any hexadecimal character
    ```
*   **Negated Character Ranges:** Define a set of characters that are *not* allowed by starting the range with `^`.
    ```gbnf
    not-newline ::= [^\n] # Matches any character except a newline
    ```
*   **Unicode Characters and Escapes:** GBNF supports full Unicode.
    *   You can directly include Unicode characters if your editor and file encoding support it:
        ```gbnf
        hiragana ::= [ぁ-ゟ]
        ```
    *   Or use escape sequences for specific Unicode code points:
        *   `\xXX` for 8-bit characters.
        *   `\uXXXX` for 16-bit Unicode code points.
        *   `\UXXXXXXXX` for 32-bit Unicode code points.
        *   Common escapes like `\n` (newline), `\t` (tab), `\r` (carriage return), `\\` (backslash), `\"` (double quote) are also supported.
    ```gbnf
    escaped-chars ::= "\u03A9" # Greek capital letter Omega
    special-char ::= "\n"    # Newline character
    ```
*   **Any Character (`.`):** The period matches any single Unicode code point.
    ```gbnf
    anychar-rule ::= "." # Matches a single character, e.g., 'a', 'Z', '7', '語', '\n'
    ```

### 3. Structure and Composition

#### Sequences
Symbols listed one after another in a rule definition form a sequence. They must appear in that order.
```gbnf
full-name ::= first-name " " last-name
first-name ::= "John"
last-name ::= "Doe"
# Output: "John Doe"
```

#### Alternatives (`|`)
The pipe symbol `|` allows you to define alternatives for a rule. The rule can match any one of the alternatives.
```gbnf
color ::= "red" | "green" | "blue"
# `color` can be "red", OR "green", OR "blue"
```

#### Grouping (`()`)
Parentheses can be used to group sequences or alternatives, often for applying quantifiers or for clarity.
```gbnf
maybe-signed-number ::= ("+" | "-")? [0-9]+
# Here, ("+" | "-") is a group. The `?` applies to the whole group.
```

### 4. Repetition and Optional Symbols (Quantifiers)

Quantifiers control how many times a preceding symbol, group, or character class can appear.

*   **`*` (Zero or More):** The preceding item can appear zero or more times.
    ```gbnf
    zero-or-more-a ::= "a"* # Matches "", "a", "aa", "aaa", etc.
    ```
*   **`+` (One or More):** The preceding item must appear at least once.
    ```gbnf
    one-or-more-b ::= "b"+ # Matches "b", "bb", "bbb", etc. (but not "")
    ```
*   **`?` (Zero or One / Optional):** The preceding item is optional (can appear zero or one time).
    ```gbnf
    optional-c ::= "c"? # Matches "" or "c"
    ```
*   **`{m}` (Exactly m times):** The preceding item must appear exactly `m` times.
    ```gbnf
    three-digits ::= [0-9]{3} # Matches "123", "007", etc.
    ```
*   **`{m,}` (At least m times):** The preceding item must appear at least `m` times.
    ```gbnf
    at-least-two-x ::= "x"{2,} # Matches "xx", "xxx", etc.
    ```
*   **`{m,n}` (Between m and n times):** The preceding item must appear between `m` and `n` times, inclusive.
    ```gbnf
    two-to-four-y ::= "y"{2,4} # Matches "yy", "yyy", "yyyy"
    ```

### 5. The `root` Rule

Every GBNF grammar **must** have a rule named `root`. This rule is the starting point for parsing and generation. The entire output generated by the model must match the pattern defined by the `root` rule.

```gbnf
root ::= sentence
sentence ::= noun " " verb "."
noun ::= "The cat" | "A dog"
verb ::= "sleeps" | "runs"
```

### 6. Comments and Whitespace

*   **Comments:** Use `#` to start a comment. Everything from `#` to the end of the line is ignored.
    ```gbnf
    # This is a comment
    rule ::= "data" # This is also a comment
    ```
*   **Whitespace in Definitions:**
    *   Spaces and tabs within literal strings (`" "`) are treated as part of the string and will appear in the output.
    *   Outside of literal strings, spaces, tabs, and newlines are primarily for formatting the grammar definition itself and are ignored by the parser (i.e., they don't become part of the generated text).
    *   If you want whitespace in your output, you must define it explicitly, either as a literal string (e.g., `" "`) or as a rule that matches whitespace characters (e.g., `ws ::= [ \t\n]*`).
    *   Newlines are allowed between rules, and also within a rule definition:
        *   Before or after an alternative marker (`|`).
        *   Inside parentheses, before or after the content.
        *   Between symbols in a sequence.

    ```gbnf
    # Well-formatted rule with explicit whitespace rule 'ws'
    list ::= item ("," ws item)*

    item ::= [a-z]+

    # Rule to explicitly match optional whitespace (zero or more spaces, tabs, or newlines)
    ws ::= [ \t\n]*
    ```
    In the `list` rule above:
    *   The `","` is a literal comma that will be in the output.
    *   `ws` is a reference to our whitespace rule. Because `ws` is defined with `*`, it can match zero whitespace characters. This means the space after the comma is optional if `ws` is used there.
    *   If `ws` was omitted (e.g., `list ::= item ("," item)*`), then no whitespace would be permitted between the comma and the next `item`.

## Common Pitfalls and Best Practices

*   **Left Recursion:** A rule is left-recursive if its definition can immediately start with a reference to itself, possibly through other rules. For example:
    ```gbnf
    # Left-recursive (problematic)
    # list ::= list item | item
    ```
    Standard GBNF parsers in `llama.cpp` do not support left recursion. You need to rewrite such rules. For example, the list above can be rewritten as:
    ```gbnf
    # Corrected (not left-recursive)
    list ::= item (item-separator item)*
    item-separator ::= " " # or whatever separator you need
    ```
*   **Performance with Repetitions:**
    *   Using many consecutive optional items like `item? item? item? ...` can be very slow.
    *   It's much more efficient to use range quantifiers: `item{0,N}` (for up to N items).
    *   Refer to `grammars/README.md` for more details on performance, especially regarding "Efficient optional repetitions".
*   **Greediness:** Quantifiers (`*`, `+`, `?`, `{m,n}`) are generally greedy, meaning they try to match as much text as possible. This is standard behavior for most regex-like systems.
*   **Ambiguity:** If a grammar can be parsed in multiple ways for the same input string, it's ambiguous. While GBNF can handle some ambiguity, highly ambiguous grammars can lead to unexpected behavior or performance issues. Try to make your rules as specific as possible.
*   **Start Simple:** Begin with a small, core part of your desired grammar and test it. Gradually add more rules and complexity.
*   **Use Comments:** Document your rules, especially complex ones, to make your grammar easier to understand and maintain.

## Using Your Grammar

Once you have written your grammar and saved it to a `.gbnf` file (e.g., `my-grammar.gbnf`), you can use it with `llama.cpp` tools like `llama-cli`.

The typical way to use it with `llama-cli` is with the `--grammar-file` argument:
```bash
./llama-cli -m <model_path> --grammar-file path/to/your/my-grammar.gbnf -p "Your prompt that should generate something according to the grammar"
```
Or, you can pass the grammar directly as a string with the `--grammar` argument:
```bash
./llama-cli -m <model_path> --grammar 'root ::= "a" "b" "c"' -p "Prompt"
```

The model will then attempt to generate text that conforms to the structure you've defined in `my-grammar.gbnf`, starting from the `root` rule.

This guide provides the foundational knowledge to write GBNF grammars. The best way to learn is by experimenting and looking at existing examples in the `grammars/` directory.

## Toy Example: Simple Arithmetic Expressions

Let's illustrate these concepts with a simple grammar that defines basic arithmetic expressions like "1 + 2" or "100 * 50".

**File: `grammars/simple-arithmetic.gbnf`**
```gbnf
# Simple GBNF grammar for basic arithmetic expressions
# Examples: "1 + 2", "123 * 45", "5 - 0", "100 / 20"

root ::= expr

# An expression consists of a number, an operator, and another number.
# Whitespace is handled around operators and numbers.
expr ::= number ws op ws number

# A number is one or more digits.
number ::= [0-9]+

# Optional whitespace (zero or more spaces or tabs).
# Note: This grammar doesn't support newlines in the middle of an expression.
ws ::= [ \t]*

# Allowed operators.
op ::= "+" | "-" | "*" | "/"
```

### How the Toy Grammar Works

*   **`root ::= expr`**: The entry point of our grammar is the `expr` rule. This means any valid output must conform to the structure of an `expr`.
*   **`expr ::= number ws op ws number`**:
    *   This defines an expression as a sequence: a `number`, followed by `ws` (whitespace), an `op` (operator), another `ws`, and finally another `number`.
*   **`number ::= [0-9]+`**:
    *   A `number` is defined as one or more (`+`) digits from `0` to `9`. This will match "0", "123", "9", etc. It won't match "1.0" or "-5".
*   **`ws ::= [ \t]*`**:
    *   `ws` (whitespace) is defined as zero or more (`*`) spaces or tabs (`[ \t]`). Because `*` allows zero occurrences, placing `ws` in the `expr` rule (`number ws op ws number`) means that spaces around the operator are optional. For example, "1+2" (where `ws` matches an empty string) and "1 + 2" (where `ws` matches a space) would both be valid according to `expr`.
*   **`op ::= "+" | "-" | "*" | "/"`**:
    *   An `op` (operator) can be one of the four characters: `+`, `-`, `*`, or `/`.

### Manual Verification of the Toy Grammar

To ensure the grammar works as intended, we can test it mentally with various strings:

**Strings that SHOULD match:**

*   `"1 + 2"`:
    *   `number` ("1") `ws` (" ") `op` ("+") `ws` (" ") `number` ("2") -> Matches `expr`.
*   `"123*45"`:
    *   `number` ("123") `ws` ("") `op` ("*") `ws` ("") `number` ("45") -> Matches `expr`. (Empty `ws` is valid).
*   `"0   -   0"`:
    *   `number` ("0") `ws` ("   ") `op` ("-") `ws` ("   ") `number` ("0") -> Matches `expr`.
*   `"99999/1"`:
    *   `number` ("99999") `ws` ("") `op` ("/") `ws` ("") `number` ("1") -> Matches `expr`.

**Strings that SHOULD NOT match:**

*   `"1 +"` (Missing second number): Fails because `expr` requires a `number` after the second `ws`.
*   `"a + 2"` (Invalid character in first number): Fails because "a" does not match `number ::= [0-9]+`.
*   `"1 & 2"` (Invalid operator): Fails because "&" does not match `op`.
*   `"1+2+3"` (Structure too complex): Matches "1+2" as an `expr`. The remaining "+3" cannot be consumed by the `root ::= expr` rule, so the whole string fails.
*   `"1.0 + 2.0"` (Floats not supported): "1.0" does not match `number ::= [0-9]+` (it matches "1" but then "." is not a digit).
*   `"+1"` (Unary operator not supported): The `expr` rule expects `number` first, not an operator.

This simple example demonstrates how rules, terminals, character classes, sequences, and alternatives work together to define a specific structure. You can expand upon this by adding more complex features like parentheses, function calls, or different data types.
```
